#! /usr/bin/env python3

import os
import sys
import shutil
import getopt
import configparser
import argparse

base_dir = os.path.dirname(os.path.realpath(__file__)) + "/"
cfg = configparser.ConfigParser()
cfg.read(base_dir + "repo/repo.ini")

commands = ["build", "update", "patch", "kexec", "del", "firm"]
flavours = os.listdir(base_dir + "flavour") + [[]]
repos = cfg.sections()

parser = argparse.ArgumentParser(description='kern')
parser.add_argument('cmd', choices=commands, action="store")
parser.add_argument('repo', choices=repos + ["all"], action="store")
parser.add_argument('flavours', choices=flavours, nargs='*', action="store")
parser.add_argument('-c', action="store", dest="config", default="l450")
args = parser.parse_args()

class col:
    blue   = '\033[94m'
    green  = '\033[92m'
    orange = '\033[93m'
    red    = '\033[91m'
    reset  = '\033[0m'

def repo_reset(repo):
    branch = cfg[repo]['branch']
    os.system("git checkout -f " + branch + " 2> /dev/null")
    #os.system("git reset --hard " + tag + " > /dev/null")
    os.system("git clean -x -f -e patch > /dev/null")
    for patch in os.listdir(base_dir + "patch"):
        if patch.endswith(".patch"):
            print("  Applying patch " + col.blue + patch + col.reset)
            #os.system("patch -p1 < " + base_dir + "patch/" + patch + ">/dev/null")
            os.system("git am --signoff -q < " + base_dir + "patch/" + patch)

def repo_update(repo):
    branch = cfg[repo]['branch']
    repo_path = base_dir + "repo/" + repo
    print("Updating " + col.green + repo + col.reset)
    print("  Fetching " + col.blue + branch + col.reset)
    if not os.path.exists(repo_path):
        os.makedirs(repo_path)
        os.chdir(repo_path)
        os.system("git init")
        os.system("git remote add origin " + cfg[section]['git'])
    else:
        os.chdir(repo_path)
    os.system("git fetch --all >/dev/null")
    repo_reset(repo)

def repo_patch(repo):
    print("Patching " + col.green + repo + col.reset)
    os.chdir(base_dir + "repo/" + repo)
    repo_reset(repo)

def make_config(repo, bname):
    if not args.flavours:
        dst = base_dir + "build/" + repo
    else:
        dst = base_dir + "build/" + repo + "_" + '_'.join(args.flavours)
    kpath = base_dir + "repo/" + repo
    if not os.path.exists(dst):
        os.makedirs(dst)
    os.chdir(kpath)
    shutil.copyfile(base_dir + "config/" + args.config, ".config")
    for flavour in args.flavours:
        print("  Applying " + col.blue + flavour + col.reset + " flavour")
        with open(base_dir + "flavour/" + flavour) as f:
            for l in f.readlines():
                os.system("./scripts/config --" + l)
    if args.flavours:
        os.system("./scripts/config --set-str localversion " + bname)
    shutil.copyfile(".config", dst + "/.config")
    os.remove(".config")
    os.chdir(base_dir + "repo/" + repo)
    print("  Refreshing config")
    os.system("KBUILD_OUTPUT=" + dst + " make olddefconfig >/dev/null")
    return dst

def make_build(repo, kpath):
    env = cfg[repo]['env']
    os.chdir(base_dir + "repo/" + repo)
    print("  Compiling linux")
    if os.system("KBUILD_OUTPUT=" + kpath + " make -j5 " + env + "> /dev/null") != 0:
        sys.exit(1)
    print("  Compiling modules")
    if os.system("KBUILD_OUTPUT=" + kpath + " make modules_prepare " + env + ">/dev/null") != 0:
        sys.exit(1)
    if os.system("KBUILD_OUTPUT=" + kpath + " make modules -j5 " + env + ">/dev/null") != 0:
        sys.exit(1)

def make_install(repo, kpath, bname):
    print("  Installing linux " + col.green + bname + col.reset)
    os.chdir(kpath)
    with open('include/config/kernel.release') as f:
        release = f.readline().rstrip('\n')
    # Install new release
    os.makedirs("/boot/" + bname, exist_ok=True)
    os.system("KBUILD_OUTPUT=" + kpath + " make modules_install >/dev/null")
    shutil.copyfile('arch/x86/boot/bzImage', '/boot/' + bname + '/vmlinuz')
    shutil.copyfile('vmlinux', '/boot/' + bname + '/vmlinux')

    print("  Creating initramfs")
    os.system(" mkinitcpio -k " + release + " -c /etc/mkinitcpio.conf -g /boot/" + bname + "/initramfs.img > /dev/null 2>&1")

    print("  Adding bootloader entry")
    with open('/boot/loader/entries/arch-' + bname + '.conf', 'w') as f:
        f.write("title  Arch Linux (" + bname + ")\n")
        f.write("linux  /" + bname + "/vmlinuz\n")
        f.write("initrd /" + bname + "/initramfs.img\n")
        f.write("options    root=/dev/sda5 rw" + "\n")

def make(repo):
    bname = repo
    if args.flavours:
        bname += "-" + '_'.join(args.flavours)
    print("Building " + col.green + repo + col.reset + " " + str(args.flavours))
    kpath = make_config(repo, bname)
    make_build(repo, kpath)
    make_install(repo, kpath, bname)

def make_del(repo):
    bname = repo
    if args.flavours:
        bname += "-" + '_'.join(args.flavours)
    print("rm /lib/modules/" + bname)
    #shutil.rmtree("/lib/modules/" + bname)
    print("rm /boot/" + bname)
    #os.remove("/boot/" + bname)
    print("/boot/loader/entries/arch-" + bname + ".conf")
    #os.remove("/boot/loader/entries/arch-" + bname + ".conf")

def make_kexec(repo):
    kpath = "/boot/" + repo
    if args.flavours:
        kpath += "-" + '_'.join(args.flavours)
    print("Kexec " + kpath)
    os.system("kexec -l " + kpath + "/vmlinuz --initrd=" + kpath + "/initramfs.img --reuse-cmdline --args-linux")
    os.system("kexec -e")

def make_firm():
    firm_path = base_dir + "firmware"
    if not os.path.exists(firm_path):
        os.makedirs(firm_path)
        os.chdir(firm_path)
        os.system("git clone git://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git")
    os.chdir(firm_path)
    print("Updating firmware")
    os.system("git pull > /dev/null")
    print("Installing firmware")
    os.system("make install > /dev/null")

if __name__ == "__main__":
    if args.cmd == "update":
        if args.repo == "all":
            for section in cfg.sections():
                repo_update(section)
        else:
                repo_update(args.repo)

    elif args.cmd == "patch":
        if args.repo == "all":
            for section in cfg.sections():
                repo_patch(section)
        else:
                repo_patch(args.repo)

    elif args.cmd == "del":
        if args.repo == "all":
            for section in cfg.sections():
                make_del(section)
        else:
                make_del(args.repo)

    elif args.cmd == "build":
        if args.repo == "all":
            exit(1)
        else:
            make(args.repo)

    elif args.cmd == "kexec":
        if args.repo == "all":
            exit(1)
        else:
            make_kexec(args.repo)

    elif args.cmd == "firm":
        make_firm()
